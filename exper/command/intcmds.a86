; Copyright 2001, 2002, 2003, 2022 S. V. Nickolas.
;
; Permission is hereby granted, free of charge, to any person obtaining a copy 
; of this software and associated documentation files (the "Software"), to 
; deal in the Software without restriction, including without limitation the 
; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
; sell copies of the Software, and to permit persons to whom the Software is 
; furnished to do so.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED 
; WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
; MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  

; This could be the start of an implementation of COMMAND.COM.
; Some of the implementations of commands are adapted from my previous attempt
; from 20 years ago, but I have rewritten everything into ASM.
;
; A list of commands that COULD be implemented here, and whether, and how
; well, they are implemented here:
;
; BREAK             Complete
; CD, CHDIR         Complete
; CHCP              Complete
; CLS               Complete
; COPY
; CTTY              Implemented but not working
; DATE              Needs debugging
;   Supports the /T switch from Windows NT
; DEL, ERASE        Complete
; DIR
; ECHO              Complete*
;   *The ON and OFF features are specific to batch files and are not supported
; LH, LOADHIGH
; MD, MKDIR         Complete
; PAUSE             Complete
; RD, RMDIR         Complete
; REM               Complete
; REN, RENAME
; TIME              Needs debugging
;   Supports the /T switch from Windows NT
; TRUENAME          Complete
; TYPE              Complete
; VER               Complete
; VERIFY            Complete
; VOL               Complete*
;   *Spurious detection of VSNs, this problem is shared with LABEL
;
; A list of commands that would really need to be implemented into COMMAND.COM
; proper once the framework is built for it:
;
; CALL              (modifies the batch state machine)
; EXIT              (exit from what?)
; FOR               (relies heavily on the internal COMMAND.COM infrastructure
;                    which isn't finished yet)
; GOTO              (modifies the batch state machine)
; IF                (needs access to errorlevels)
; PATH              (modifies the environment)
; PROMPT            (modifies the environment)
; SET               (modifies the environment)
; SHIFT             (modifies the batch state machine)
;
; Error checking is spotty.
;
; ============================================================================
;
; Thoughts on implementing the other internal commands...
;
; COPY's built-in concatenation feature, plus the sensitivity of location for 
; the /A and /B switches, makes it a right pain to implement in ASM.  I could 
; probably just use the MS-DOS 2.11 implementation.
;
; DIR, until MS-DOS 5, only had two switches - /P and /W.  That's easy enough.
; Adding /B and /L, that's not too hard.  /A, that's a little more painful as 
; I would need to write a parser for it.  /O, that's a lot more painful since 
; not only does it need a parser, it needs a sort engine, and that will bloat 
; up the code quite a bit (although the exchange sort algo I use is actually 
; pretty code-efficient if slower than mud).  (DR DOS uses a completely 
; different set of switches, except for the abovementioned /P and /W.)  Maybe
; I could do what I did with RMFCOM - implement the simple switches but leave
; the more complicated /A, /O and /S completely out.
;
; LOADHIGH, I have no idea in hell how to implement this.
;
; REN, I have the original RMFCOM implementation which uses FCBs, but it might 
; be better to use a hybrid FCB/Xenix method, similar to what I did with COMP, 
; which like REN can take wildcards in both the source and target filespecs.
;
; As for any other commands, they are tied too deep into the internal state of 
; COMMAND.COM to worry about until more of the scaffolding is set up (e.g., 
; the half-written INT24 handler)...

          cpu       8086
          org       0x0100
entry:    mov       ah, 0x30
          int       0x21
          xchg      ah, al
          cmp       ax, 0x0200
          jae       okdos
          mov       dx, edos1
          call      wrstr
          int       0x20                ; DOS 1 EXIT
crittab:  db        "Write protect violation$"
          db        "Invalid unit$"
          db        "Drive not ready$"
          db        "Invalid device request$"
          db        "Data CRC failure$"
          db        "Invalid device request parameters$"
          db        "Seek error$"
          db        "Invalid media type$"
          db        "Sector not found$"
          db        "Printer out of paper$"
          db        "Write fault$"
          db        "Read fault$"
          db        "General failure$"
          db        "Sharing violation$"
          db        "Lock violation$"
          db        "Invalid disk change$"
          db        "FCB unavailable$"
          db        "Share buffer overflow$"
          db        0
anyerr:   db        "Unknown error$"
ereading: db        " reading $"
ewriting: db        " writing $"
edrive:   db        "drive $"
edevice:  db        "device $"
eabort:   db        "Abort$"
eretry:   db        "Retry$"
eignore:  db        "Ignore$"
efail:    db        "Fail$"
ecomma:   db        ", $"
eqmark:   db        "? $"
edos1:    db        "Incorrect DOS version", 13, 10, "$"
enoargs:  db        "Required parameter missing", 13, 10, "$"
eargs:    db        "Too many parameters", 13, 10, "$"
earg:     db        "Invalid parameter", 13, 10, "$"
ecmd:     db        "Invalid command", 13, 10, "$"
efunc:    db        "Invalid function", 13, 10, "$"
edev:     db        "Invalid device", 13, 10, "$"
e404:     db        "File not found", 13, 10, "$"
epath:    db        "Invalid path", 13, 10, "$"
e9001:    db        "Access denied", 13, 10, "$"
eread:    db        "Cannot read file", 13, 10, "$"
eactive:  db        "Active code page: $"
ecpset:   db        "Cannot set code page", 13, 10, "$"
ecpget:   db        "Cannot retrieve code page", 13, 10, "$"
emkdir:   db        "Cannot create directory", 13, 10, "$"
ermdir:   db        "Cannot remove directory", 13, 10, "$"
edelok:   db        ": delete (Y/N)? $"
eall:     db        "Are you sure (Y/N)? $"
epwd:     db        "Current drive is no longer valid$"
ecurdate: db        "Current date is $"
ecurtime: db        "Current time is $"
enewdate: db        "Enter new date $"
enewtime: db        "Enter new time: $"
emdy:     db        "(mm-dd-yy): $"
edmy:     db        "(dd-mm-yy): $"
eymd:     db        "(yy-mm-dd): $"
edate:    db        "Invalid date", 13, 10, "$"
etime:    db        "Invalid time", 13, 10, "$"
edr:      db        "DR DOS emulating " ; FALL INTO
eibm:     db        "PC $"
ems:      db        "MS-$"
edosver:  db        "DOS Version $"
erev:     db        "Revision $"
edosisin: db        13, 10, "DOS is in $"
elodos:   db        "low memory", 13, 10, "$"
ehidos:   db        "HMA", 13, 10, "$"
ebreak:   db        "BREAK is $"
everify:  db        "VERIFY"            ; FALL INTO
mlabel:   db        " is $"
eon:      db        "ON", 13, 10, "$"
eoff:     db        "OFF", 13, 10, "$"
eonoff:   db        "Must specify ON or OFF", 13, 10, "$"
volblk:   db        "A:\*.*", 0
mvolume:  db        13, 10, " Volume in drive $"
mnolabel: db        " has no label", 13, 10, "$"
mvolser:  db        " Volume Serial Number is $"
namtank:  db        "           ", 0
epause:   db        "Press any key to continue . . . $"
edays:    db        "Sun$Mon$Tue$Wed$Thu$Fri$Sat$"
eswitch:  db        "Invalid switch - /"
xswitch:  db        0
ecrlf:    db        13, 10, "$"
eansi:    db        27, "[2J$"

maxcol:   db        79                  ; Must be in this order
maxrow:   db        24
mediaid:  dw        0x0000
serlo:    dw        0x0000
serhi:    dw        0x0000
midlab:   times 11  db 0x00
fsys:     times 8   db 0x00
osmajor:  db        0x00
ffblk:    times 128 db 0x00
fin       equ       ffblk+0x001E
drvchk:   db        0x00
verr:                                   ; SAME AS
eraq:     db        0x00
eargflag: db        0x00
arifflag: db        0x00
cmdname:  db        9 dup 0x00
tank:     dw        0x0000
inword:   dw        0x0000
datebuf:  db        4 dup 0x00
numbuf:   db        6 dup 0x00
i18nbuf:  db        34 dup 0x00
old24:    dd        0x00000000

killspc:  cmp       byte [si], 0
          je        .2
          cmp       byte [si], ' '
          je        .1
          cmp       byte [si], 0x09
          jne       .2
.1:       inc       si
          jmp short killspc
.2:       ret

smash:    cmp       ah, 'a'             ; Smash lowercase to uppercase.
          jb        .1
          cmp       ah, 'z'
          ja        .1
          and       ah, 0x5F
.1:       ret

; Append "\*.*" if si points to the name of a directory 
; (useful for DEL and DIR).

starstar: push      si                  ; Save pointer
          mov       dx, si              ; Get attributes
          mov       ax, 0x4300
          int       0x21
          pop       si                  ; Restore pointer
          jc        .1                  ; Just return on fail
          and       cl, 0x10            ; If not directory, just return
          jnz       .2
.1:       ret
.2:       push      si                  ; Save pointer
.3:       mov       ah, [si]
          or        ah, ah              ; Find NUL terminator
          jz        .4
          inc       si
          jmp short .3
.4:       mov       word [si], '\*'     ; Add "\*.*" at the end
          add       si, 2
          mov       word [si], '.*'
          add       si, 2
          mov       byte [si], 0
          pop       si                  ; Restore pointer
          ret

getlin:   mov       word [linbuf], 0x0080
          mov       ah, 0x0A
          mov       dx, linbuf
          int       0x21
          mov       dx, ecrlf
          call      wrstr
          mov       ah, [linbuf+1]
          ret

; Read a line from the keyboard using DOSKEY, if available, and fall back to
; plain MS-DOS API if not.  Not hooked up to anything yet.

xgetlin:  mov       word [linbuf], 0x0080
          mov       ax, 0x4800          ; Is DOSKEY installed?
          int       0x2F
          mov       dx, linbuf          ; Set up the pointer either way
          or        al, al              ; 0=not installed
          jz        .1                  ; Not installed; use DOS GETLIN
          mov       ax, 0x4810          ; Installed; use DOSKEY GETLIN
          int       0x2F
          or        ax, ax              ; 0=no error
          jz        .2                  ; ...so if there WAS an error,
.1:       mov       ah, 0x0A            ;   fall back on the MS-DOS API.
          int       0x21
.2:       mov       dx, ecrlf
          call      wrstr
          mov       ah, [linbuf+1]
          ret

modisp:   mov       al, [datebuf+3]
          jmp short mddisp
dadisp:   mov       al, [datebuf+2]
mddisp:   cmp       al, 10
          jae       .1
          push      ax
          mov       dl, '0'
          mov       ah, 0x02
          int       0x21
          pop       ax
.1:       xor       ah, ah
          jmp short wrnum
yrdisp:   mov       ax, [datebuf]       ; FALL INTO
wrnum:    mov       byte [numbuf+6], 0  ; Recycle the end of linbuf2.
          mov       di, numbuf+5        ; (Only does an unsigned word.
.1:       xor       dx, dx              ;  Output will be a C string.)
          mov       bx, 10              ; DECIMAL
          div       bx                  ; AX=(DX:AX)/BX; DX=(DX:AX)%BX
          add       dl, '0'             ; Convert remainder to ASCII
          mov       [di], dl            ; Write it into buffer
          dec       di                  ; Step down
          or        ax, ax              ; Anything left?
          jnz       .1                  ; Yes, so keep going.
          mov       dx, di
          inc       dx                  ; FALL INTO
wrstrc:   push      di
          mov       di, dx
.1:       mov       ah, 0x02            ; PUTCHAR
          mov       dl, [di]
          or        dl, dl              ; Null terminator?
          jz        .2                  ; Yes, restore di and exit
          int       0x21
          inc       di
          jmp short .1
.2:       pop       di
          ret

wrwrd:    mov       [tank+1], al
          call      wrbyt
          mov       ah, [tank+1]
wrbyt:    mov       [tank], ah          ; Do the same for digits.
          mov       cl, 4
          shr       ah, cl
          call      hexit
          mov       ah, [tank]
hexit:    and       ah, 0x0F            ; Convert nibble to ASCII
          cmp       ah, 0x09
          ja        .1
          or        ah, 0x30            ; 0-9 to ASCII
          jmp short .2
.1:       add       ah, 0x37            ; make 0x0A -> 0x41 'A'
.2:       mov       dl, ah
          mov       ah, 0x02            ; PUTCH
          int       0x21
          ret

; SKELETON.  Not hooked up to anything.

new24:    push      bx
          push      cx
          push      dx
          push      si
          push      di
          push      bp
          push      ds
          push      es
          
                    
          pop       es
          pop       ds
          pop       bp
          pop       di
          pop       si
          pop       dx
          pop       cx
          pop       bx
          iret 

; Not hooked up to anything.

getmsg24: mov       cx, di              ; If DI.L=error number, print error
          xor       ch, ch
          mov       si, crittab
.1:       cmp       ch, cl
          je        .5
.2:       cmp       byte [si], 0
          je        .5
.3:       cmp       byte [si], '$'
          je        .4
          inc       si
          jmp short .3
.4:       inc       ch
          jmp short .1
.5:       inc       si
.6:       mov       dx, si
          jmp       wrstr

; Not hooked up to anything.

arif:     mov       dx, eabort
          call      wrstr
          test      byte [arifflag], 0x10
          jz        .1
          mov       dx, ecomma
          call      wrstr
          mov       dx, eretry
          call      wrstr
.1:       test      byte [arifflag], 0x20
          jz        .2
          mov       dx, ecomma
          call      wrstr
          mov       dx, eignore
          call      wrstr
.2:       test      byte [arifflag], 0x08
          jz        .1
          mov       dx, ecomma
          call      wrstr
          mov       dx, efail
          call      wrstr
.3:       mov       dx, eqmark
          call      wrstr
.4:       mov       ah, 0x01
          int       0x21
          push      ax
          mov       dx, ecrlf
          call      wrstr
          pop       ax
          mov       ah, al
          call      smash
          cmp       ah, 'A'
          je        .8
          test      byte [arif], 0x10
          jz        .5
          cmp       ah, 'R'
          je        .9
.5:       test      byte [arif], 0x20
          jz        .6
          cmp       ah, 'I'
          je        .10
.6:       test      byte [arif], 0x08
          jz        .7
          cmp       ah, 'F'
          je        .11
.7:       jmp       arif
.8:       mov       al, 0x02
          jmp short .12
.9:       mov       al, 0x01
          jmp short .12
.10:      xor       al, al
          jmp short .12
.11:      mov       al, 0x03
.12:      ret

init:     mov       ax, 0x3524
          int       0x21
          mov       [old24+2], es
          push      cs
          pop       es
          mov       [old24], bx
;         mov       ax, 0x2524
;         mov       dx, new24
;         int       0x21
          ret
          
uninit:   mov       ax, 0x2524
          mov       dx, [old24+2]
          mov       ds, dx
          mov       dx, cs:[old24]
          int       0x21
          push      cs
          pop       ds
          ret

wrstr:    mov       ah, 0x09
          int       0x21
          ret
okdos:    mov       si, 0x0081
          mov       di, cmdname
          call      killspc
          cmp       byte [si], 0x0D
          jne       .1
          call      uninit
          mov       ax, 0x4CFF
          int       0x21
.1:       mov       ah, [si]            ; Get command
          cmp       ah, 0x0D
          je        cmdonly
          cmp       ah, ' '
          je        getargs
          cmp       ah, 0x09
          je        getargs
          cmp       ah, '/'
          je        getargs
          call      smash
          mov       [di], ah
          inc       si
          inc       di
          cmp       di, cmdname+9
          jb        .1                  ; FALL INTO
badcmd:   mov       dx, ecmd            ; FALL INTO
scream:   call      wrstr
die:      call      uninit
          mov       ax, 0x4C01
          int       0x21
cmdonly:  mov       byte [di], 0
          mov       byte [buf], 0
          jmp short selcmd
getargs:  mov       di, buf
          call      killspc
.1:       mov       ah, [si]
          cmp       ah, 0x0D
          je        .2
          mov       [di], ah
          inc       si
          inc       di
          cmp       si, 0x0100
          jb        .1
.2:       mov       byte [di], 0        ; FALL INTO
selcmd:   mov       bx, cmdtab
.1:       mov       di, bx
          add       di, 2
          mov       si, cmdname
.2:       mov       ah, [si]
          cmp       ah, [di]
          jne       .3
          or        ah, ah
          je        .6
          inc       si
          inc       di
          jmp short .2
.3:       add       bx, 2               ; Find next entry
.4:       mov       ah, [bx]
          or        ah, ah
          je        .5
          inc       bx
          jmp short .4
.5:       inc       bx
          mov       dx, [bx]            ; End of table?
          or        dx, dx
          je        badcmd              ; Yes, die screaming
          jmp short .1
.6:       jmp       [bx]

zero:     mov       dl, '0'
          jmp short chrcom
colon:    mov       dl, ':'
          jmp short chrcom
dash:     mov       dl, '-'
chrcom:   mov       ah, 0x02
          int       0x21
          ret

getyear:  call      getnum
          mov       bx, [inword]
          cmp       bx, 80
          jb        .2                  ; 0-79
          cmp       bx, 100             ; 80-99
          jb        .3
          cmp       bx, 1980            ; 100-1979
          jb        baddate
          cmp       bx, 2100            ; 1980-2099
          ja        baddate
.1:       mov       [datebuf], bx
          clc
          ret
.2:       add       bx, 2000
          jmp short .1
.3:       add       bx, 1900
          jmp short .1
baddate:  mov       dx, edate
          call      wrstr
          stc
          ret

getmonth: call      getnum
          mov       bh, [inword]
          or        bh, bh              ; > 255 = invalid
          jz        baddate
          or        bl, bl              ; 0 = invalid
          jz        baddate
          cmp       bl, 12              ; Only 12 months in a year
          ja        baddate
          mov       cl, 5               ; Combine with day into one byte
          shl       bl, cl
          and       dl, 0xE0
          or        dl, bl
          ret

getday:   call      getnum
          mov       bx, [inword]
          or        bh, bh              ; > 255 = invalid
          jnz       baddate
          or        bl, bl              ; 0 = invalid
          jz        baddate
          cmp       bl, 31              ; No month has more than 31 days.
          ja        baddate
          and       dl, 0x1F            ; Combine with month into one byte
          or        dl, bl
          ret

getnum:   mov       word [inword], 0
.1:       mov       ah, [si]            ; Read digits.
          cmp       ah, '0'             ; If not a digit, we're done
          jb        .2
          cmp       ah, '9'
          ja        .2
          and       ah, 0x0F            ; Mask off the ASCII
          mov       bl, ah              ; Multiply existing value by 10 and
          xor       bh, bh              ;   add our digit to it.
          mov       ax, 10
          mul       word [inword]
          add       ax, bx
          mov       [inword], ax
          inc       si                  ; Next char
          jmp short .1
.2:       ret

; If next character is "/", "-" or ".", skip it.  Otherwise, die screaming.

getsep:   mov       ah, [si]
          cmp       ah, '/'
          je        sepok
          cmp       ah, '-'
          je        sepok
          cmp       ah, '.'
          jne       baddate
sepok:    inc       si
          clc
          ret
getcolon: cmp       byte [si], ':'
          je        sepok
          mov       dx, etime
          call      wrstr
          stc
          ret

; We cannot do the day-of-month sanity check until we know the month, because
; months do not all have the same length, or the year, because every 4 years
; (it's not this simple but within MS-DOS's range of accepted years it's close
; enough) February is intercalated.

mosan:    mov       ah, dl              ; Day of month sanity check
          mov       al, dl              ; (a.k.a. "30 days hath September...")
          mov       cl, 5
          shr       ah, cl
          and       al, 0x1F
          cmp       ah, 2               ; February
          jne       .2
          mov       bl, 28
          test      dh, 0x04            ; Oversimplification, but true during
          jnz       .1                  ; our valid year range (1980-2099)
          inc       bl
.1:       cmp       al, bl
          ja        baddate
          ret
.2:       mov       bl, 30
          cmp       al, 4               ; April
          je        .1
          cmp       al, 6               ; June
          je        .1
          cmp       al, 9               ; September
          je        .1
          cmp       al, 11              ; November
          je        .1
          inc       bl
          jmp short .1

timedisp: mov       dx, ecurtime
          call      wrstr
          mov       ah, 0x2C
          int       0x21
          mov       [datebuf], cx
          mov       [datebuf+2], dx
          mov       al, ch
          xor       ah, ah
          call      wrnum
          call      colon
          mov       al, [datebuf]
          cmp       al, 10
          jae       .1
          call      zero
          mov       al, [datebuf]
.1:       xor       ah, ah
          call      wrnum
          call      colon
          mov       al, [datebuf+3]
          cmp       al, 10
          jae       .2
          call      zero
          mov       al, [datebuf+3]
.2:       xor       ah, ah
          call      wrnum
          mov       dl, '.'
          mov       ah, 0x02
          int       0x21
          mov       al, [datebuf+2]
          cmp       al, 10
          jae       .3
          call      zero
          mov       al, [datebuf+2]
.3:       xor       ah, ah
          jmp       wrnum

datedisp: mov       dx, ecurdate
          call      wrstr
          mov       ah, 0x2A
          int       0x21
          mov       [datebuf], cx
          mov       [datebuf+2], dx
          shl       al, 1
          shl       al, 1
          xor       ah, ah
          mov       dx, edays
          add       dx, ax
          call      wrstr
          mov       dl, ' '
          mov       ah, 0x02
          int       0x21
          mov       dx, i18nbuf
          mov       ax, 0x3800
          int       0x21
          mov       ah, [i18nbuf]
          cmp       ah, 1
          je        prymd
          ja        prdmy
          call      modisp
          call      dash
          call      dadisp
          jmp short mdydmy
prdmy:    call      dadisp
          call      dash
          call      modisp
mdydmy:   call      dash
          jmp       yrdisp
prymd:    call      yrdisp
          call      dash
          call      modisp
          call      dash
          jmp       dadisp

; For stuff that takes exactly one argument, easiest way to validate

argsan:   mov       si, buf
          cmp       byte [si], 0
          je        noargs
.1:       mov       ah, [si]
          or        ah, ah
          jz        .3
          cmp       ah, ' '
          je        .2
          cmp       ah, 0x09
          je        .2
          inc       si
          jmp short .1
.2:       call      killspc
          mov       ah, [si]
          or        ah, ah
          jnz       .4
.3:       mov       si, buf
          ret
.4:       jmp short args
noargs:   mov       dx, enoargs
          jmp       scream
args:     mov       dx, eargs
          jmp       scream

c_type:   call      argsan
          mov       ax, 0x3D00
          mov       dx, buf
          int       0x21
          jc        .3
          mov       [inword], ax
.1:       mov       ah, 0x3F
          mov       bx, [inword]
          mov       cx, 1
          mov       dx, tank
          int       0x21
          jc        .4
          or        ax, ax
          jz        .2
          mov       dl, [tank]
          cmp       dl, 0x1B            ; EOF
          je        .2
          mov       ah, 0x02
          int       0x21
          jmp short .1
.2:       mov       bx, [inword]
          mov       ah, 0x3E
          int       0x21
          jmp       c_rem
.3:       mov       dx, e404
          jmp short .5
.4:       mov       ah, 0x3E
          mov       bx, [inword]
          int       0x21
          mov       dx, eread
.5:       jmp       scream

c_chcp:   mov       si, buf
          call      killspc
          cmp       byte [si], 0
          jnz       .1
          mov       ax, 0x6601          ; GETCHCP
          int       0x21
          jc        .2
          mov       dx, eactive
          call      wrstr
          mov       ax, bx
          call      wrnum
          mov       dx, ecrlf
          call      wrstr
          jmp short .4
.1:       call      getnum
          mov       bx, [inword]
          mov       ax, 0x6602          ; SETCHCP
          int       0x21
          jnc       .4
          mov       dx, ecpset
          jmp short .3
.2:       mov       dx, ecpget
.3:       jmp       scream
.4:       jmp       c_rem

c_cls:    mov       ax, 0x4400
          mov       bx, 1               ; stdout
          int       0x21
          jc        .2
          test      dx, 0x0010          ; is CON:
          jz        .2
          mov       byte [maxrow], 24
          mov       ah, 0x12            ; do we have an EGA?
          mov       bx, 0xFF10
          mov       cx, 0xFFFF
          int       0x10
          cmp       cx, 0xFFFF          ; unchanged = MDA or CGA
          je        .1                  ;   = always 25 lines
          mov       ax, 0x0040          ; otherwise, lines-1 is stored at
          push      es                  ;   0040:0084
          mov       es, ax
          mov       ah, [es:0x0084]
          pop       es
          mov       [maxrow], ah
.1:       mov       ah, 0x0F            ; this, OTOH, works on anything
          int       0x10
          dec       ah
          mov       [maxcol], ah
          mov       ax, 0x0600          ; method used by MS-DOS COMMAND.COM
          mov       bh, 0x07
          xor       cx, cx
          mov       dx, [maxcol]        ; pulls in maxrow also
          push      bp                  ; BUG WORKAROUND
          int       0x10
          pop       bp
          xor       dx, dx
          mov       ah, 0x02
          xor       bh, bh
          int       0x10
          jmp short .3
.2:       mov       dx, eansi
          call      wrstr
.3:       jmp       c_rem

c_md:     call      argsan
          mov       dx, buf
          mov       ah, 0x39
          int       0x21
          jnc       mcrdend
          mov       dx, emkdir
          jmp       scream
c_cd:     cmp       byte [buf], 0       ; Null - get CWD on current drive
          jne       .1
          mov       ah, 0x19
          int       0x21
          mov       dl, al
          inc       dl
          add       al, 'A'
          mov       [buf], al
          jmp short .2
.1:       call      argsan
          cmp       word [buf+1], 0x003A
          jne       .3
          mov       ah, [buf]
          call      smash
          mov       [buf], ah
          sub       ah, '@'
          mov       dl, ah
.2:       mov       word [buf+1], ':\'
          mov       si, buf+3
          mov       ah, 0x47
          int       0x21
          jc        .4
          mov       dx, buf
          call      wrstrc
          mov       dx, ecrlf
          call      wrstr
          jmp short mcrdend
.3:       mov       dx, buf
          mov       ah, 0x3B
          int       0x21
          jnc       mcrdend
          mov       dx, epath
          jmp       scream
.4:       mov       dx, epwd
          call      wrstr
          mov       dx, ecrlf
          jmp       scream

c_rd:     call      argsan
          mov       dx, buf
          mov       ah, 0x3A
          int       0x21
          jnc       mcrdend
          mov       dx, ermdir
          jmp       scream
mcrdend:  jmp       c_rem

c_time:   mov       word [datebuf], 0
          mov       word [datebuf+2], 0
          cmp       byte [buf], 0
          je        .2
          cmp       word [buf], '/T'
          je        .1
          cmp       word [buf], '/t'
          jne       .4
.1:       call      timedisp
          mov       dx, ecrlf
          call      wrstr
          jmp       c_rem
.2:       call      timedisp
.3:       mov       dx, ecrlf
          call      wrstr
          mov       dx, enewtime
          call      wrstr
          call      getlin
.4:       cmp       byte [getlin], 0x0D
          jne       .5
          jmp       c_rem
.5:       call      getnum
          mov       ah, [inword]
          mov       [datebuf+1], ah
          cmp       byte [si], 0
          je        .9
          call      getcolon
          jc        .3
          call      getnum
          mov       ah, [inword]
          mov       [datebuf], ah
          cmp       byte [si], 0
          je        .9
          call      getcolon
          jc        .3
          mov       ah, [inword]
          mov       [datebuf+3], ah
          cmp       byte [si], 0
          je        .9
          cmp       byte [si], '.'
          je        .7
.6:       mov       dx, etime
          call      wrstr
          jmp short .3
.7:       call      getnum
          mov       al, [inword]
          cmp       al, 10
          jae       .8
          mov       cl, 10
          xor       ah, ah
          mul       cl
.8:       mov       [datebuf+2], ah
.9:       mov       cx, [datebuf]
          mov       dx, [datebuf+2]
          mov       ah, 0x2D
          int       0x21
          or        al, al
          jnz       .6
.10:      jmp       c_rem

c_date:   cmp       byte [buf], 0
          je        .2
          cmp       word [buf], '/T'
          je        .1
          cmp       word [buf], '/t'
          jne       .4
.1:       call      datedisp
          mov       dx, ecrlf
          call      wrstr
          jmp       c_rem
.2:       call      datedisp
.3:       mov       dx, ecrlf
          call      wrstr
          mov       dx, enewdate
          call      wrstr
          mov       al, [i18nbuf]
          shl       al, 1
          xor       ah, ah
          mov       bx, dateseqs
          add       bx, ax
          mov       dx, [bx]
          call      wrstr
          call      getlin
.4:       cmp       byte [getlin], 0x0D
          je        c_rem
          mov       ax, 0x3800
          int       0x21
          mov       ah, [i18nbuf]
          cmp       ah, 1
          je        .5
          ja        .7
          call      getmonth
          jc        .3
          call      getsep
          call      getday
          jc        .3
          jmp short .6
.5:       call      getday
          jc        .3
          call      getsep
          call      getmonth
          jc        .3
.6:       call      getsep
          call      getyear
          jc        .3
          jmp short .8
.7:       call      getyear
          jc        .3
          call      getsep
          call      getmonth
          jc        .3
          call      getsep
          call      getday
          jc        .3
.8:       mov       cx, [datebuf]
          mov       dx, [datebuf+2]
          mov       ah, 0x2B
          int       0x21
          inc       al
          jz        .9
          jmp       c_rem
.9:       mov       dx, edate
          call      wrstr
          jmp       .3

c_break:  cmp       byte [buf], 0
          jne       setbrk
          mov       dx, ebreak
          call      wrstr
          mov       ax, 0x3300
          int       0x21
          mov       al, dl
isonoff:  or        al, al
          jz        .1
          mov       dx, eon
          jmp short .2
.1:       mov       dx, eoff
.2:       call      wrstr
          jmp       c_rem
setbrk:   call      getonoff
          jnc       .1
          mov       dx, eonoff
          jmp       scream
.1:       mov       dl, al
          mov       ax, 0x3301
          int       0x21
          jmp short c_rem

c_verify: cmp       byte [buf], 0
          jne       setvfy
          mov       dx, everify
          call      wrstr
          mov       ah, 0x54
          int       0x21
          jmp short isonoff
setvfy:   call      getonoff
          jnc       .1
          mov       dx, eonoff
          jmp       scream
.1:       xor       dl, dl
          mov       ah, 0x2E
          int       0x21
          jmp short c_rem

getonoff: mov       ah, [buf]
          call      smash
          cmp       ah, 'O'
          je        .1
          stc
          ret
.1:       mov       ax, [buf+1]
          xchg      ah, al
          call      smash
          cmp       ax, 'N'
          je        .2
          xchg      ah, al
          call      smash
          cmp       ax, 'FF'
          je        .3
.2:       mov       al, 1
          clc
          ret
.3:       cmp       byte [buf+3], 0
          je        .4
          stc
          ret
.4:       xor       al, al
          clc
          ret

c_echo:   mov       si, buf
.1:       mov       dl, [si]
          or        dl, dl
          je        .2
          mov       ah, 0x02
          int       0x21
          inc       si
          jmp short .1
.2:       mov       dx, ecrlf
          call      wrstr               ; FALL INTO
c_rem:    call      uninit
          mov       ax, 0x4C00          ; Also successful exit.
          int       0x21

c_pause:  mov       dx, epause
          call      wrstr
          mov       ah, 0x08
          int       0x21
          mov       dx, ecrlf
          call      wrstr
          jmp short c_rem

c_ver:    mov       byte [verr], 0x00
          mov       si, buf
          call      killspc
          cmp       byte [si], 0
          je        .2
          cmp       byte [si], '/'
          je        .1
          jmp       args
.1:       mov       ah, byte [si+1]
          call      smash
          mov       byte [verr], 0xFF
          cmp       ah, 'R'
          je        .2
          mov       [xswitch], ah       ; Set up message
          mov       dx, eswitch         ; "Invalid switch"
          jmp       scream
.2:       mov       dx, ecrlf
          call      wrstr
          stc
          mov       ax, 0x4452
          int       0x21
          jc        .3                  ; Not DR DOS
          mov       byte [verr], 0x00   ; Don't do VER /R on DR DOS
          mov       ah, 0x30
          int       0x21
          mov       [datebuf], ax
          mov       dx, edr
          jmp       .6
.3:       mov       ax, 0x3000
          int       0x21
          cmp       al, 5               ; /R requires DOS 5
          jae       .4
          mov       byte [verr], 0x00
.4:       mov       [datebuf], ax
          or        bh, bh
          jz        .5                  ; PC DOS
          cmp       bh, 0xFF
          jne       .7
          mov       dx, ems
          jmp short .6
.5:       mov       dx, eibm
          test      byte [verr], 0xFF
          jz        .6
          mov       byte [verr], 0x80   ; mark set!
.6:       call      wrstr
.7:       mov       dx, edosver
          call      wrstr
          mov       al, [datebuf]
          xor       ah, ah
          call      wrnum
          mov       dl, '.'
          mov       ah, 0x02
          int       0x21
          cmp       byte [datebuf+1], 10
          jae       .8
          call      zero
.8:       mov       al, [datebuf+1]
          xor       ah, ah
          call      wrnum
          mov       dx, ecrlf
          call      wrstr
          cmp       byte [verr], 0
          jne       .9
          jmp       c_rem
.9:       mov       dx, erev
          call      wrstr
          mov       ax, 0x3306          ; TRUEVER
          int       0x21
          push      dx
          add       dl, '0'
          cmp       byte [verr], 0x80   ; mark get!
          je        .10                 ; use letters for MS-DOS,
                                        ;     numbers for PC DOS
          add       dl, 'A'-'0'
.10:      mov       ah, 0x02
          int       0x21
          mov       dx, edosisin
          call      wrstr
          pop       dx
          test      dh, 0x10
          je        .11
          mov       dx, ehidos
          jmp short .12
.11:      mov       dx, elodos
.12:      call      wrstr
          jmp       c_rem

c_truenm: mov       ah, [buf]           ; No arg?
          or        ah, ah
          jnz       .1
          mov       si, buf             ; Make it "."
          mov       [si], word 0x002E
          jmp short .4

.1:       mov       si, buf
.2:       mov       ah, [si]
          or        ah, ah              ; end of buffer?
          jz        .3                  ; yes, skip
          inc       si                  ; no, keep going
          jmp short .2
.3:       mov       si, buf
.4:       mov       ah, [si]            ; skip prefix whitespace
          cmp       ah, ' '
          jne       .5
          inc       si
          jmp short .4

.5:       mov       di, buf+128         ; set output buffer to end of code
          mov       ah, 0x60            ; TRUENAME
          int       0x21
          jnc       .6                  ; carry set = error
          mov       dx, efunc
          jmp       scream

.6:       mov       si, buf+128         ; find NUL, change it to CRLF +
.7:       mov       ah, [si]            ;   DOS string terminator
          or        ah, ah
          jz        .8
          inc       si
          cmp       si, buf+256
          jb        .7
.8:       mov       [si], byte 0x0D
          inc       si
          mov       [si], byte 0x0A
          inc       si
          mov       [si], byte '$'
          mov       dx, buf+128
          call      wrstr
          jmp       c_rem

c_del:    mov       byte [eraq], 0      ; Set defaults
          mov       byte [eargflag], 0
          mov       si, buf             ; Command line buffer
          mov       di, delbuf1
          call      killspc
          cmp       byte [si], 0        ; Blank command line
          jne       .1
          mov       dx, enoargs         ; "Required parameter missing"
          jmp       scream
.1:       mov       ah, [si]
          cmp       ah, '/'             ; Switch?
          jne       .3                  ; No, skip
          mov       ah, [si+1]
          call      smash               ; Force uppercase
          cmp       ah, 'P'
          je        .2
          mov       [xswitch], ah       ; Set up message
          mov       dx, eswitch         ; "Invalid switch"
          jmp       scream
.2:       mov       byte [eraq], 0xFF   ; Set prompt flag
          add       si, 2               ; Skip over it
          call      killspc
          cmp       di, delbuf1         ; Was there anything typed?
          je        .1
          mov       byte [eargflag], 0xFF
          jmp short .1
.3:       cmp       ah, ' '             ; End of parameter
          je        .5
          cmp       ah, 0x09
          je        .5
          cmp       ah, 0               ; End of line
          je        .6
          cmp       byte [eargflag], 0xFF
          jne       .4                  ; OK to copy char
          mov       dx, eargs           ; "Too many arguments"
          jmp       scream
.4:       call      smash               ; Force uppercase
          mov       [di], ah            ; Store
          inc       si                  ; Adjust pointers
          inc       di
          cmp       si, 0x0100          ; End of buffer
          jne       .1
          jmp short .6
.5:       call      killspc             ; Mark we have a parameter alreaady
          mov       byte [eargflag], 0xFF
          jmp short .1
.6:       mov       byte [di], 0        ; Add a NUL terminator
          inc       di
          mov       si, delbuf1
          call      starstar
.7:       cmp       byte [si], 0        ; Get basename
          je        .8
          inc       si
          jmp short .7
.8:       dec       si
          cmp       byte [si], ':'      ; Drive separator?
          je        .9                  ; Yes, done
          cmp       byte [si], '\'      ; Path separator?
          je        .9                  ; Yes, done
          cmp       si, delbuf1         ; Beginning of buffer?
          jne       .8                  ; No, keep going
          dec       si
.9:       inc       si
          mov       ax, 0x2900          ; Stuff basename into an FCB
          mov       di, delbuf2
          int       0x21
          mov       si, delbuf2+1       ; Did it come out as "???????????" ?
          mov       cl, 11
.10:      cmp       byte [si], '?'
          jne       .12                 ; Nope
          inc       si
          dec       cl
          jne       .10
          cmp       byte [eraq], 0      ; Was /P set?
          jne       .12                 ; Yes, so skip
.11:      mov       dx, eall            ; "Are you sure (Y/N)?"
          call      wrstr
          mov       ah, 0x01            ; GETCHE
          int       0x21
          push      ax
          mov       dx, ecrlf
          call      wrstr
          pop       ax
          mov       ah, al              ; Force uppercase
          call      smash
          cmp       ah, 'Y'             ; Yes?
          je        .12
          cmp       ah, 'N'             ; No?
          jne       .11
          jmp       die
.12:      mov       byte [delbuf2], 0
          mov       si, delbuf1         ; Do dirname
.13:      cmp       byte [si], 0
          je        .14
          inc       si
          jmp short .13
.14:      dec       si
          cmp       byte [si], ':'
          je        .15
          cmp       byte [si], '\'
          je        .15
          cmp       si, delbuf1
          jne       .14
.15:      mov       bx, si              ; Copy dirname
          inc       bx
          mov       si, delbuf1
          mov       di, delbuf2
.16:      mov       ah, [si]
          mov       [di], ah
          inc       si
          inc       di
          cmp       si, bx              ; Until we hit our mark
          jne       .16
          mov       byte [di], 0        ; Add NUL terminator
          mov       dx, delbuf3         ; set buffer for FINDFIRST
          mov       ah, 0x1A
          int       0x21
          mov       ah, 0x4E            ; FINDFIRST
          xor       cx, cx
          mov       dx, delbuf1
          int       0x21
          jnc       .19                 ; We gotcha!
          cmp       al, 0x12            ; No files found
          je        .18
.17:      mov       dx, epath           ; "Invalid path"
          jmp       scream
.18:      mov       dx, e404            ; "File not found"
          jmp       scream
.19:      mov       si, delbuf2         ; strcpy(buf4, buf2);
          mov       di, delbuf4
.20:      mov       ah, [si]
          mov       [di], ah
          or        ah, ah
          jz        .21
          inc       si
          inc       di
          jmp short .20
.21:      mov       si, delbuf3+0x1E    ; strcat(buf4, buf3+0x1E);
.22:      mov       ah, [si]
          mov       [di], ah
          or        ah, ah
          jz        .23
          inc       si
          inc       di
          jmp short .22
.23:      cmp       byte [eraq], 0x00   ; Skip if /P not set
          je        .26
.24:      mov       dx, delbuf4         ; Output filename
          call      wrstrc
          mov       dx, edelok          ; "Delete (Y/N)?"
          call      wrstr
          mov       ah, 0x01            ; GETCHE
          int       0x21
          mov       ah, al              ; Force uppercase
          call      smash
          push      ax
          mov       dx, ecrlf
          call      wrstr
          pop       ax
          cmp       ah, 'Y'             ; Yes?
          je        .26                 ; Yes, go ahead
          cmp       ah, 'N'             ; No?
          jne       .24                 ; No, ask again
.25:      mov       ah, 0x4F            ; FINDNEXT
          int       0x21
          jnc       .19                 ; Go back, Jack, and do it again
          cmp       al, 0x12            ; No more files
          jne       .27
          mov       ax, 0x4C00
          int       0x21                ; EXIT CODE 0
.26:      mov       dx, delbuf4         ; Zap
          mov       ah, 0x41            ; UNLINK
          int       0x21
          jnc       .25                 ; Success
.27:      cmp       al, 0x02
          je        .18
          cmp       al, 0x03
          je        .17
          mov       dx, e9001           ; FALL INTO
          jmp       scream

c_vol:    cmp       byte [buf], 0
          je        .2
          cmp       word [buf+1], ':'
          je        .1
          mov       dx, earg
          jmp       scream
.1:       mov       ah, [buf]
          call      smash
          mov       al, ah
          jmp short .3
.2:       mov       ah, 0x19            ; GETDISK
          int       0x21
          add       al, 'A'
.3:       mov       [volblk], al
          mov       dx, mvolume
          call      wrstr
          mov       ah, 0x02            ; PUTCHAR
          mov       dl, [volblk]
          int       0x21
          mov       dx, ffblk
          mov       ah, 0x1A            ; SETDTA
          int       0x21
          mov       ax, 0x4E00          ; FINDFIRST
          mov       cx, 0x0008          ; label
          mov       dx, volblk
          int       0x21
          jnc       gotlabel
          mov       dx, mnolabel
          call      wrstr
          jmp short voldone
gotlabel: mov       ax, fin
          mov       di, ax
          mov       si, ax
.1:       mov       ah, [si]            ; strrchr(fin, '.')
          or        ah, ah
          je        .2
          inc       si
          jmp short .1
.2:       dec       si
          cmp       si, di
          je        nodot
          mov       ah, [si]
          cmp       ah, '.'
          jne       .2
          mov       byte [si], 0
          mov       si, tank            ; copy label over field with spaces
.3:       mov       ah, [di]
          or        ah, ah
          je        .4
          mov       [si], ah
          inc       di
          inc       si
          jmp short .3
.4:       inc       di
.5:       mov       ah, [di]
          mov       [si], ah            ; copy the terminator too
          or        ah, ah
          je        .6
          inc       si
          inc       di
          jmp short .5
.6:       call      dois
          mov       di, tank
          jmp short until0

dois:     mov       dx, mlabel
          call      wrstr
          ret
          
nodot:    call      dois
          mov       di, fin
until0:   mov       dl, [di]
          or        dl, dl
          je        .1
          mov       ah, 0x02
          int       0x21
          inc       di
          jmp short until0
.1:       mov       dx, ecrlf
          call      wrstr

voldone:  mov       ah, osmajor
          cmp       ah, 0x04
          jb        noser               ; only MS-DOS 4 and later have VSNs
          xor       bh, bh
          mov       bl, [buf]
          or        bl, bl
          jz        .1
          and       bl, 0x1F
.1:       mov       cx, 0x0866
          mov       dx, mediaid
          mov       ax, 0x440D          ; GET_MID
          int       0x21                ; get Volume Serial Number and label
          mov       ax, serlo
          or        ax, ax
          jne       hasser
          mov       ax, serhi
          or        ax, ax
          je        noser
hasser:   mov       dx, mvolser
          call      wrstr
          mov       ax, [serhi]
          call      wrwrd
          mov       dl, '-'
          mov       ah, 0x02
          int       0x21
          mov       ax, [serlo]
          call      wrwrd
          mov       dx, ecrlf
          call      wrstr
noser:    ret

c_ctty:   call      argsan
          mov       ah, 0x3D            ; OPEN
          mov       dx, buf
          int       0x21
          jc        .1
          mov       bx, ax
          mov       ax, 0x4400          ; IOCTL
          int       0x21
          test      dl, 0x80            ; Device?
          jnz       .2
          mov       ah, 0x4E            ; CLOSE
          int       0x21
.1:       mov       dx, edev
          jmp       scream
.2:       xor       dh, dh
          or        dl, 3               ; Mark as stdin and stdout
          mov       ax, 0x4401
          int       0x21
          xor       cx, cx              ; ->0 (stdin)
          mov       ah, 0x46            ; DUP2
          int       0x21
          inc       cx                  ; ->1 (stdout)
          mov       ah, 0x46            ; DUP2
          int       0x21
          inc       cx                  ; ->2 (stderr)
          mov       ah, 0x46            ; DUP2
          int       0x21
          mov       ah, 0x4E            ; CLOSE
          int       0x21
          jmp       c_rem

cmdtab:   dw        c_break
          db        "BREAK", 0
          dw        c_cd
          db        "CD", 0
          dw        c_chcp
          db        "CHCP", 0
          dw        c_cd
          db        "CHDIR", 0
          dw        c_cls
          db        "CLS", 0
          dw        c_ctty
          db        "CTTY", 0
          dw        c_date
          db        "DATE", 0
          dw        c_del
          db        "DEL", 0
          dw        c_echo
          db        "ECHO", 0
          dw        c_del
          db        "ERASE", 0
          dw        c_md
          db        "MD", 0
          dw        c_md
          db        "MKDIR", 0
          dw        c_pause
          db        "PAUSE", 0
          dw        c_rd
          db        "RD", 0
          dw        c_rem
          db        "REM", 0
          dw        c_rd
          db        "RMDIR", 0
          dw        c_time
          db        "TIME", 0
          dw        c_truenm
          db        "TRUENAME", 0
          dw        c_type
          db        "TYPE", 0
          dw        c_ver
          db        "VER", 0
          dw        c_verify
          db        "VERIFY", 0
          dw        c_vol
          db        "VOL", 0
          dw        0

dateseqs: dw        emdy, edmy, eymd

linbuf:   dw        0x0000              ; FALL INTO
buf:
delbuf1   equ       buf+128
delbuf2   equ       buf+192
delbuf3   equ       buf+256
delbuf4   equ       buf+320
