; Copyright 2001, 2002, 2003, 2022 S. V. Nickolas.
;
; Permission is hereby granted, free of charge, to any person obtaining a copy 
; of this software and associated documentation files (the "Software"), to 
; deal in the Software without restriction, including without limitation the 
; rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
; sell copies of the Software, and to permit persons to whom the Software is 
; furnished to do so.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED 
; WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
; MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  

; This could be the start of an implementation of COMMAND.COM.
; Some of the implementations of commands are adapted from my previous attempt
; from 20 years ago, but I have rewritten everything into ASM.
;
; A list of commands that COULD be implemented here, and whether, and how
; well, they are implemented here:
;
; BREAK             Complete
; CD, CHDIR         Complete
; CHCP              Complete
; CLS               Complete
; COPY
; CTTY
; DATE              Needs debugging
;   Supports the /T switch from Windows NT
; DEL, ERASE
; DIR
; ECHO              Complete*
;   *the ON and OFF features are specific to batch files and are not supported
; FOR
; LH, LOADHIGH
; MD, MKDIR         Complete
; PAUSE             Complete
; RD, RMDIR         Complete
; REM               Complete
; REN, RENAME
; TIME              Needs debugging
;   Supports the /T switch from Windows NT
; TRUENAME          Complete
; TYPE              Complete
; VER               Complete
;   Does not support the /R switch from MS-DOS/PC DOS 5+
; VERIFY            Complete
; VOL               Complete
;   Spurious detection of VSNs, this problem is shared with LABEL
;
; Error checking is spotty.

          cpu       8086
          org       0x0100
entry:    mov       ah, 0x30
          int       0x21
          xchg      ah, al
          cmp       ax, 0x0200
          jae       okdos
          mov       dx, edos1
          call      wrstr
          int       0x20                ; DOS 1 EXIT
edos1:    db        "Incorrect DOS version", 13, 10, "$"
enoargs:  db        "Required parameter missing", 13, 10, "$"
eargs:    db        "Too many parameters", 13, 10, "$"
earg:     db        "Invalid parameter", 13, 10, "$"
ecmd:     db        "Invalid command", 13, 10, "$"
efunc:    db        "Invalid function", 13, 10, "$"
e404:     db        "File not found", 13, 10, "$"
eread:    db        "Cannot read file", 13, 10, "$"
eactive:  db        "Active code page: $"
ecpset:   db        "Cannot set code page", 13, 10, "$"
ecpget:   db        "Cannot retrieve code page", 13, 10, "$"
emkdir:   db        "Cannot create directory", 13, 10, "$"
echdir:   db        "Cannot set directory", 13, 10, "$"
ermdir:   db        "Cannot remove directory", 13, 10, "$"
epwd:     db        "Current drive is no longer valid", 13, 10, "$"
ecurdate: db        "Current date is $"
ecurtime: db        "Current time is $"
enewdate: db        "Enter new date $"
enewtime: db        "Enter new time: $"
emdy:     db        "(mm-dd-yy): $"
edmy:     db        "(dd-mm-yy): $"
eymd:     db        "(yy-mm-dd): $"
edate:    db        "Invalid date", 13, 10, "$"
etime:    db        "Invalid time", 13, 10, "$"
edr:      db        "DR DOS emulating " ; FALL INTO
eibm:     db        "PC $"
ems:      db        "MS-$"
edosver:  db        "DOS Version $"
ebreak:   db        "BREAK is $"
everify:  db        "VERIFY"            ; FALL INTO
mlabel:   db        " is $"
eon:      db        "ON", 13, 10, "$"
eoff:     db        "OFF", 13, 10, "$"
eonoff:   db        "Must specify ON or OFF", 13, 10, "$"
volblk:   db        "A:\*.*", 0
mvolume:  db        13, 10, " Volume in drive $"
mnolabel: db        " has no label", 13, 10, "$"
mvolser:  db        " Volume Serial Number is $"
namtank:  db        "           ", 0
epause:   db        "Press any key to continue . . . $"
edays:    db        "Sun$Mon$Tue$Wed$Thu$Fri$Sat$"
ecrlf:    db        13, 10, "$"
eansi:    db        27, "[2J$"

maxcol:   db        79                  ; Must be in this order
maxrow:   db        24
mediaid:  dw        0x0000
serlo:    dw        0x0000
serhi:    dw        0x0000
midlab:   times 11  db 0x00
fsys:     times 8   db 0x00
osmajor:  db        0x00
ffblk:    times 128 db 0x00
fin       equ       ffblk+0x001E
drvchk:   db        0x00
cmdname:  db        9 dup 0x00
tank:     dw        0x0000
inword:   dw        0x0000
datebuf:  db        4 dup 0x00
numbuf:   db        6 dup 0x00
i18nbuf:  db        34 dup 0x00

killspc:  cmp       byte [si], 0
          je        .2
          cmp       byte [si], ' '
          je        .1
          cmp       byte [si], 0x09
          jne       .2
.1:       inc       si
          jmp short killspc
.2:       ret

smash:    cmp       ah, 'a'             ; Smash lowercase to uppercase.
          jb        .1
          cmp       ah, 'z'
          ja        .1
          and       ah, 0x5F
.1:       ret

getlin:   mov       word [linbuf], 0x0080
          mov       ah, 0x0A
          mov       dx, linbuf
          int       0x21
          mov       dx, ecrlf
          call      wrstr
          mov       ah, [linbuf+1]
          ret

modisp:   mov       al, [datebuf+3]
          jmp short mddisp
dadisp:   mov       al, [datebuf+2]
mddisp:   cmp       al, 10
          jae       .1
          push      ax
          mov       dl, '0'
          mov       ah, 0x02
          int       0x21
          pop       ax
.1:       xor       ah, ah
          jmp short wrnum
yrdisp:   mov       ax, [datebuf]       ; FALL INTO
wrnum:    mov       byte [numbuf+6], 0  ; Recycle the end of linbuf2.
          mov       di, numbuf+5        ; (Only does an unsigned word.
.1:       xor       dx, dx              ;  Output will be a C string.)
          mov       bx, 10              ; DECIMAL
          div       bx                  ; AX=(DX:AX)/BX; DX=(DX:AX)%BX
          add       dl, '0'             ; Convert remainder to ASCII
          mov       [di], dl            ; Write it into buffer
          dec       di                  ; Step down
          or        ax, ax              ; Anything left?
          jnz       .1                  ; Yes, so keep going.
          mov       dx, di
          inc       dx                  ; FALL INTO
wrstrc:   push      di
          mov       di, dx
.1:       mov       ah, 0x02            ; PUTCHAR
          mov       dl, [di]
          or        dl, dl              ; Null terminator?
          jz        .2                  ; Yes, restore di and exit
          int       0x21
          inc       di
          jmp short .1
.2:       pop       di
          ret

wrwrd:    mov       [tank+1], al
          call      wrbyt
          mov       ah, [tank+1]
wrbyt:    mov       [tank], ah          ; Do the same for digits.
          mov       cl, 4
          shr       ah, cl
          call      hexit
          mov       ah, [tank]
hexit:    and       ah, 0x0F            ; Convert nibble to ASCII
          cmp       ah, 0x09
          ja        .1
          or        ah, 0x30            ; 0-9 to ASCII
          jmp short .2
.1:       add       ah, 0x37            ; make 0x0A -> 0x41 'A'
.2:       mov       dl, ah
          mov       ah, 0x02            ; PUTCH
          int       0x21
          ret

wrstr:    mov       ah, 0x09
          int       0x21
          ret
okdos:    mov       si, 0x0081
          mov       di, cmdname
          call      killspc
          cmp       byte [si], 0x0D
          jne       .1
          mov       ax, 0x4CFF
          int       0x21
.1:       mov       ah, [si]            ; Get command
          cmp       ah, 0x0D
          je        cmdonly
          cmp       ah, ' '
          je        getargs
          cmp       ah, 0x09
          je        getargs
          cmp       ah, '/'
          je        getargs
          call      smash
          mov       [di], ah
          inc       si
          inc       di
          cmp       di, cmdname+9
          jb        .1                  ; FALL INTO
badcmd:   mov       dx, ecmd            ; FALL INTO
scream:   call      wrstr
          mov       ax, 0x4C01
          int       0x21
cmdonly:  mov       byte [di], 0
          mov       byte [buf], 0
          jmp short selcmd
getargs:  mov       di, buf
          call      killspc
.1:       mov       ah, [si]
          cmp       ah, 0x0D
          je        .2
          mov       [di], ah
          inc       si
          inc       di
          cmp       si, 0x0100
          jb        .1
.2:       mov       byte [di], 0        ; FALL INTO
selcmd:   mov       bx, cmdtab
.1:       mov       di, bx
          add       di, 2
          mov       si, cmdname
.2:       mov       ah, [si]
          cmp       ah, [di]
          jne       .3
          or        ah, ah
          je        .6
          inc       si
          inc       di
          jmp short .2
.3:       add       bx, 2               ; Find next entry
.4:       mov       ah, [bx]
          or        ah, ah
          je        .5
          inc       bx
          jmp short .4
.5:       inc       bx
          mov       dx, [bx]            ; End of table?
          or        dx, dx
          je        badcmd              ; Yes, die screaming
          jmp short .1
.6:       jmp       [bx]

zero:     mov       dl, '0'
          jmp short chrcom
colon:    mov       dl, ':'
          jmp short chrcom
dash:     mov       dl, '-'
chrcom:   mov       ah, 0x02
          int       0x21
          ret

getyear:  call      getnum
          mov       bx, [inword]
          cmp       bx, 80
          jb        .2                  ; 0-79
          cmp       bx, 100             ; 80-99
          jb        .3
          cmp       bx, 1980            ; 100-1979
          jb        baddate
          cmp       bx, 2100            ; 1980-2099
          ja        baddate
.1:       mov       [datebuf], bx
          clc
          ret
.2:       add       bx, 2000
          jmp short .1
.3:       add       bx, 1900
          jmp short .1
baddate:  mov       dx, edate
          call      wrstr
          stc
          ret

getmonth: call      getnum
          mov       bh, [inword]
          or        bh, bh              ; > 255 = invalid
          jz        baddate
          or        bl, bl              ; 0 = invalid
          jz        baddate
          cmp       bl, 12              ; Only 12 months in a year
          ja        baddate
          mov       cl, 5               ; Combine with day into one byte
          shl       bl, cl
          and       dl, 0xE0
          or        dl, bl
          ret

getday:   call      getnum
          mov       bx, [inword]
          or        bh, bh              ; > 255 = invalid
          jnz       baddate
          or        bl, bl              ; 0 = invalid
          jz        baddate
          cmp       bl, 31              ; No month has more than 31 days.
          ja        baddate
          and       dl, 0x1F            ; Combine with month into one byte
          or        dl, bl
          ret

getnum:   mov       word [inword], 0
.1:       mov       ah, [si]            ; Read digits.
          cmp       ah, '0'             ; If not a digit, we're done
          jb        .2
          cmp       ah, '9'
          ja        .2
          and       ah, 0x0F            ; Mask off the ASCII
          mov       bl, ah              ; Multiply existing value by 10 and
          xor       bh, bh              ;   add our digit to it.
          mov       ax, 10
          mul       word [inword]
          add       ax, bx
          mov       [inword], ax
          inc       si                  ; Next char
          jmp short .1
.2:       ret

; If next character is "/", "-" or ".", skip it.  Otherwise, die screaming.

getsep:   mov       ah, [si]
          cmp       ah, '/'
          je        sepok
          cmp       ah, '-'
          je        sepok
          cmp       ah, '.'
          jne       baddate
sepok:    inc       si
          clc
          ret
getcolon: cmp       byte [si], ':'
          je        sepok
          mov       dx, etime
          call      wrstr
          stc
          ret

; We cannot do the day-of-month sanity check until we know the month, because
; months do not all have the same length, or the year, because every 4 years
; (it's not this simple but within MS-DOS's range of accepted years it's close
; enough) February is intercalated.

mosan:    mov       ah, dl              ; Day of month sanity check
          mov       al, dl              ; (a.k.a. "30 days hath September...")
          mov       cl, 5
          shr       ah, cl
          and       al, 0x1F
          cmp       ah, 2               ; February
          jne       .2
          mov       bl, 28
          test      dh, 0x04            ; Oversimplification, but true during
          jnz       .1                  ; our valid year range (1980-2099)
          inc       bl
.1:       cmp       al, bl
          ja        baddate
          ret
.2:       mov       bl, 30
          cmp       al, 4               ; April
          je        .1
          cmp       al, 6               ; June
          je        .1
          cmp       al, 9               ; September
          je        .1
          cmp       al, 11              ; November
          je        .1
          inc       bl
          jmp short .1

timedisp: mov       dx, ecurtime
          call      wrstr
          mov       ah, 0x2C
          int       0x21
          mov       [datebuf], cx
          mov       [datebuf+2], dx
          mov       al, ch
          xor       ah, ah
          call      wrnum
          call      colon
          mov       al, [datebuf]
          cmp       al, 10
          jae       .1
          call      zero
          mov       al, [datebuf]
.1:       xor       ah, ah
          call      wrnum
          call      colon
          mov       al, [datebuf+3]
          cmp       al, 10
          jae       .2
          call      zero
          mov       al, [datebuf+3]
.2:       xor       ah, ah
          call      wrnum
          mov       dl, '.'
          mov       ah, 0x02
          int       0x21
          mov       al, [datebuf+2]
          cmp       al, 10
          jae       .3
          call      zero
          mov       al, [datebuf+2]
.3:       xor       ah, ah
          jmp       wrnum

datedisp: mov       dx, ecurdate
          call      wrstr
          mov       ah, 0x2A
          int       0x21
          mov       [datebuf], cx
          mov       [datebuf+2], dx
          shl       al, 1
          shl       al, 1
          xor       ah, ah
          mov       dx, edays
          add       dx, ax
          call      wrstr
          mov       dl, ' '
          mov       ah, 0x02
          int       0x21
          mov       dx, i18nbuf
          mov       ax, 0x3800
          int       0x21
          mov       ah, [i18nbuf]
          cmp       ah, 1
          je        prymd
          ja        prdmy
          call      modisp
          call      dash
          call      dadisp
          jmp short mdydmy
prdmy:    call      dadisp
          call      dash
          call      modisp
mdydmy:   call      dash
          jmp       yrdisp
prymd:    call      yrdisp
          call      dash
          call      modisp
          call      dash
          jmp       dadisp

; For stuff that takes exactly one argument, easiest way to validate

argsan:   mov       si, buf
          cmp       byte [si], 0
          je        noargs
.1:       mov       ah, [si]
          or        ah, ah
          jz        .3
          cmp       ah, ' '
          je        .2
          cmp       ah, 0x09
          je        .2
          inc       si
          jmp short .1
.2:       call      killspc
          mov       ah, [si]
          or        ah, ah
          jnz       .4
.3:       mov       si, buf
          ret
.4:       jmp short args
noargs:   mov       dx, enoargs
          jmp       scream
args:     mov       dx, eargs
          jmp       scream

c_type:   call      argsan
          mov       ax, 0x3D00
          mov       dx, buf
          int       0x21
          jc        .3
          mov       [inword], ax
.1:       mov       ah, 0x3F
          mov       bx, [inword]
          mov       cx, 1
          mov       dx, tank
          int       0x21
          jc        .4
          or        ax, ax
          jz        .2
          mov       dl, [tank]
          cmp       dl, 0x1B            ; EOF
          je        .2
          mov       ah, 0x02
          int       0x21
          jmp short .1
.2:       mov       bx, [inword]
          mov       ah, 0x3E
          int       0x21
          jmp       c_rem
.3:       mov       dx, e404
          jmp short .5
.4:       mov       ah, 0x3E
          mov       bx, [inword]
          int       0x21
          mov       dx, eread
.5:       jmp       scream

c_chcp:   mov       si, buf
          call      killspc
          cmp       byte [si], 0
          jnz       .1
          mov       ax, 0x6601          ; GETCHCP
          int       0x21
          jc        .2
          mov       dx, eactive
          call      wrstr
          mov       ax, bx
          call      wrnum
          mov       dx, ecrlf
          call      wrstr
          jmp short .4
.1:       call      getnum
          mov       bx, [inword]
          mov       ax, 0x6602          ; SETCHCP
          int       0x21
          jnc       .4
          mov       dx, ecpset
          jmp short .3
.2:       mov       dx, ecpget
.3:       jmp       scream
.4:       jmp       c_rem

c_cls:    mov       ax, 0x4400
          mov       bx, 1               ; stdout
          int       0x21
          jc        .2
          test      dx, 0x0010          ; is CON:
          jz        .2
          mov       byte [maxrow], 24
          mov       ah, 0x12            ; do we have an EGA?
          mov       bx, 0xFF10
          mov       cx, 0xFFFF
          int       0x10
          cmp       cx, 0xFFFF          ; unchanged = MDA or CGA
          je        .1                  ;   = always 25 lines
          mov       ax, 0x0040          ; otherwise, lines-1 is stored at
          push      es                  ;   0040:0084
          mov       es, ax
          mov       ah, [es:0x0084]
          pop       es
          mov       [maxrow], ah
.1:       mov       ah, 0x0F            ; this, OTOH, works on anything
          int       0x10
          dec       ah
          mov       [maxcol], ah
          mov       ax, 0x0600          ; method used by MS-DOS COMMAND.COM
          mov       bh, 0x07
          xor       cx, cx
          mov       dx, [maxcol]        ; pulls in maxrow also
          push      bp                  ; BUG WORKAROUND
          int       0x10
          pop       bp
          xor       dx, dx
          mov       ah, 0x02
          xor       bh, bh
          int       0x10
          jmp short .3
.2:       mov       dx, eansi
          call      wrstr
.3:       jmp       c_rem

c_md:     call      argsan
          mov       dx, buf
          mov       ah, 0x39
          int       0x21
          jnc       mcrdend
          mov       dx, emkdir
          jmp       scream
c_cd:     cmp       byte [buf], 0       ; Null - get CWD on current drive
          jne       .1
          mov       ah, 0x19
          int       0x21
          mov       dl, al
          inc       dl
          add       al, 'A'
          mov       [buf], al
          jmp short .2
.1:       call      argsan
          cmp       word [buf+1], 0x003A
          jne       .3
          mov       ah, [buf]
          call      smash
          mov       [buf], ah
          sub       ah, '@'
          mov       dl, ah
.2:       mov       word [buf+1], ':\'
          mov       si, buf+3
          mov       ah, 0x47
          int       0x21
          jc        .4
          mov       dx, buf
          call      wrstrc
          mov       dx, ecrlf
          call      wrstr
          jmp short mcrdend
.3:       mov       dx, buf
          mov       ah, 0x3B
          int       0x21
          jnc       mcrdend
          mov       dx, echdir
          jmp       scream
.4:       mov       dx, epwd
          jmp       scream

c_rd:     call      argsan
          mov       dx, buf
          mov       ah, 0x3A
          int       0x21
          jnc       mcrdend
          mov       dx, ermdir
          jmp       scream
mcrdend:  jmp       c_rem

c_time:   mov       word [datebuf], 0
          mov       word [datebuf+2], 0
          cmp       byte [buf], 0
          je        .2
          cmp       word [buf], '/T'
          je        .1
          cmp       word [buf], '/t'
          jne       .4
.1:       call      timedisp
          mov       dx, ecrlf
          call      wrstr
          jmp       c_rem
.2:       call      timedisp
.3:       mov       dx, ecrlf
          call      wrstr
          mov       dx, enewtime
          call      wrstr
          call      getlin
.4:       cmp       byte [getlin], 0x0D
          jne       .5
          jmp       c_rem
.5:       call      getnum
          mov       ah, [inword]
          mov       [datebuf+1], ah
          cmp       byte [si], 0
          je        .9
          call      getcolon
          jc        .3
          call      getnum
          mov       ah, [inword]
          mov       [datebuf], ah
          cmp       byte [si], 0
          je        .9
          call      getcolon
          jc        .3
          mov       ah, [inword]
          mov       [datebuf+3], ah
          cmp       byte [si], 0
          je        .9
          cmp       byte [si], '.'
          je        .7
.6:       mov       dx, etime
          call      wrstr
          jmp short .3
.7:       call      getnum
          mov       al, [inword]
          cmp       al, 10
          jae       .8
          mov       cl, 10
          xor       ah, ah
          mul       cl
.8:       mov       [datebuf+2], ah
.9:       mov       cx, [datebuf]
          mov       dx, [datebuf+2]
          mov       ah, 0x2D
          int       0x21
          or        al, al
          jnz       .6
.10:      jmp       c_rem

c_date:   cmp       byte [buf], 0
          je        .2
          cmp       word [buf], '/T'
          je        .1
          cmp       word [buf], '/t'
          jne       .4
.1:       call      datedisp
          mov       dx, ecrlf
          call      wrstr
          jmp       c_rem
.2:       call      datedisp
.3:       mov       dx, ecrlf
          call      wrstr
          mov       dx, enewdate
          call      wrstr
          mov       al, [i18nbuf]
          shl       al, 1
          xor       ah, ah
          mov       bx, dateseqs
          add       bx, ax
          mov       dx, [bx]
          call      wrstr
          call      getlin
.4:       cmp       byte [getlin], 0x0D
          je        c_rem
          mov       ax, 0x3800
          int       0x21
          mov       ah, [i18nbuf]
          cmp       ah, 1
          je        .5
          ja        .7
          call      getmonth
          jc        .3
          call      getsep
          call      getday
          jc        .3
          jmp short .6
.5:       call      getday
          jc        .3
          call      getsep
          call      getmonth
          jc        .3
.6:       call      getsep
          call      getyear
          jc        .3
          jmp short .8
.7:       call      getyear
          jc        .3
          call      getsep
          call      getmonth
          jc        .3
          call      getsep
          call      getday
          jc        .3
.8:       mov       cx, [datebuf]
          mov       dx, [datebuf+2]
          mov       ah, 0x2B
          int       0x21
          inc       al
          jz        .9
          jmp       c_rem
.9:       mov       dx, edate
          call      wrstr
          jmp       .3

c_break:  cmp       byte [buf], 0
          jne       setbrk
          mov       dx, ebreak
          call      wrstr
          mov       ax, 0x3300
          int       0x21
          mov       al, dl
isonoff:  or        al, al
          jz        .1
          mov       dx, eon
          jmp short .2
.1:       mov       dx, eoff
.2:       call      wrstr
          jmp       c_rem
setbrk:   call      getonoff
          jnc       .1
          mov       dx, eonoff
          jmp       scream
.1:       mov       dl, al
          mov       ax, 0x3301
          int       0x21
          jmp short c_rem

c_verify: cmp       byte [buf], 0
          jne       setvfy
          mov       dx, everify
          call      wrstr
          mov       ah, 0x54
          int       0x21
          jmp short isonoff
setvfy:   call      getonoff
          jnc       .1
          mov       dx, eonoff
          jmp       scream
.1:       xor       dl, dl
          mov       ah, 0x2E
          int       0x21
          jmp short c_rem

getonoff: mov       ah, [buf]
          call      smash
          cmp       ah, 'O'
          je        .1
          stc
          ret
.1:       mov       ax, [buf+1]
          xchg      ah, al
          call      smash
          cmp       ax, 'N'
          je        .2
          xchg      ah, al
          call      smash
          cmp       ax, 'FF'
          je        .3
.2:       mov       al, 1
          clc
          ret
.3:       cmp       byte [buf+3], 0
          je        .4
          stc
          ret
.4:       xor       al, al
          clc
          ret

c_echo:   mov       si, buf
.1:       mov       dl, [si]
          or        dl, dl
          je        .2
          mov       ah, 0x02
          int       0x21
          inc       si
          jmp short .1
.2:       mov       dx, ecrlf
          call      wrstr               ; FALL INTO
c_rem:    mov       ax, 0x4C00          ; Also successful exit.
          int       0x21

c_pause:  mov       dx, epause
          call      wrstr
          mov       ah, 0x08
          int       0x21
          mov       dx, ecrlf
          call      wrstr
          jmp short c_rem

c_ver:    stc
          mov       ax, 0x4452
          int       0x21
          jc        .1                  ; Not DR DOS
          mov       ah, 0x30
          int       0x21
          mov       [datebuf], ax
          mov       dx, edr
          jmp       .3
.1:       mov       ax, 0x3000
          int       0x21
          mov       [datebuf], ax
          or        bh, bh
          jz        .2                  ; PC DOS
          cmp       bh, 0xFF
          jne       .4
          mov       dx, ems
          jmp short .3
.2:       mov       dx, eibm
.3:       call      wrstr
.4:       mov       dx, edosver
          call      wrstr
          mov       al, [datebuf]
          xor       ah, ah
          call      wrnum
          mov       dl, '.'
          mov       ah, 0x02
          int       0x21
          cmp       byte [datebuf+1], 10
          jae       .5
          call      zero
.5:       mov       al, [datebuf+1]
          xor       ah, ah
          call      wrnum
          mov       dx, ecrlf
          call      wrstr
          jmp short c_rem

c_truenm: mov       ah, [buf]           ; No arg?
          or        ah, ah
          jnz       .1
          mov       si, buf             ; Make it "."
          mov       [si], word 0x002E
          jmp short .4

.1:       mov       si, buf
.2:       mov       ah, [si]
          or        ah, ah              ; end of buffer?
          jz        .3                  ; yes, skip
          inc       si                  ; no, keep going
          jmp short .2
.3:       mov       si, buf
.4:       mov       ah, [si]            ; skip prefix whitespace
          cmp       ah, ' '
          jne       .5
          inc       si
          jmp short .4

.5:       mov       di, buf+128         ; set output buffer to end of code
          mov       ah, 0x60            ; TRUENAME
          int       0x21
          jnc       .6                  ; carry set = error
          mov       dx, efunc
          jmp       scream

.6:       mov       si, buf+128         ; find NUL, change it to CRLF +
.7:       mov       ah, [si]            ;   DOS string terminator
          or        ah, ah
          jz        .8
          inc       si
          cmp       si, buf+256
          jb        .7
.8:       mov       [si], byte 0x0D
          inc       si
          mov       [si], byte 0x0A
          inc       si
          mov       [si], byte '$'
          mov       dx, buf+128
          call      wrstr
          jmp       c_rem

c_vol:    cmp       byte [buf], 0
          je        .2
          cmp       word [buf+1], ':'
          je        .1
          mov       dx, earg
          jmp       scream
.1:       mov       ah, [buf]
          call      smash
          mov       al, ah
          jmp short .3
.2:       mov       ah, 0x19            ; GETDISK
          int       0x21
          add       al, 'A'
.3:       mov       [volblk], al        ; XXX: C version also checks drive
          
          mov       dx, mvolume
          call      wrstr
          mov       ah, 0x02            ; PUTCHAR
          mov       dl, [volblk]
          int       0x21
          mov       dx, ffblk
          mov       ah, 0x1A            ; SETDTA
          int       0x21
          
          mov       ax, 0x4E00          ; FINDFIRST
          mov       cx, 0x0008          ; label
          mov       dx, volblk
          int       0x21
          jnc       gotlabel
          mov       dx, mnolabel
          call      wrstr
          jmp short voldone
gotlabel: mov       ax, fin
          mov       di, ax
          mov       si, ax
.1:       mov       ah, [si]            ; strrchr(fin, '.')
          or        ah, ah
          je        .2
          inc       si
          jmp short .1
.2:       dec       si
          cmp       si, di
          je        nodot
          mov       ah, [si]
          cmp       ah, '.'
          jne       .2
          mov       byte [si], 0
          mov       si, tank            ; copy label over field with spaces
.3:       mov       ah, [di]
          or        ah, ah
          je        .4
          mov       [si], ah
          inc       di
          inc       si
          jmp short .3
.4:       inc       di
.5:       mov       ah, [di]
          mov       [si], ah            ; copy the terminator too
          or        ah, ah
          je        .6
          inc       si
          inc       di
          jmp short .5
.6:       call      dois
          mov       di, tank
          jmp short until0

dois:     mov       dx, mlabel
          call      wrstr
          ret
          
nodot:    call      dois
          mov       di, fin
until0:   mov       dl, [di]
          or        dl, dl
          je        .1
          mov       ah, 0x02
          int       0x21
          inc       di
          jmp short until0
.1:       mov       dx, ecrlf
          call      wrstr

voldone:  mov       ah, osmajor
          cmp       ah, 0x04
          jb        noser               ; only MS-DOS 4 and later have VSNs
          xor       bh, bh
          mov       bl, [buf]
          or        bl, bl
          jz        .1
          and       bl, 0x1F
.1:       mov       cx, 0x0866
          mov       dx, mediaid
          mov       ax, 0x440D          ; GET_MID
          int       0x21                ; get Volume Serial Number and label
          mov       ax, serlo
          or        ax, ax
          jne       hasser
          mov       ax, serhi
          or        ax, ax
          je        noser
hasser:   mov       dx, mvolser
          call      wrstr
          mov       ax, [serhi]
          call      wrwrd
          mov       dl, '-'
          mov       ah, 0x02
          int       0x21
          mov       ax, [serlo]
          call      wrwrd
          mov       dx, ecrlf
          call      wrstr
noser:    ret
          
cmdtab:   dw        c_break
          db        "BREAK", 0
          dw        c_cd
          db        "CD", 0
          dw        c_chcp
          db        "CHCP", 0
          dw        c_cd
          db        "CHDIR", 0
          dw        c_cls
          db        "CLS", 0
          dw        c_date
          db        "DATE", 0
          dw        c_echo
          db        "ECHO", 0
          dw        c_md
          db        "MD", 0
          dw        c_md
          db        "MKDIR", 0
          dw        c_pause
          db        "PAUSE", 0
          dw        c_rd
          db        "RD", 0
          dw        c_rem
          db        "REM", 0
          dw        c_rd
          db        "RMDIR", 0
          dw        c_time
          db        "TIME", 0
          dw        c_truenm
          db        "TRUENAME", 0
          dw        c_type
          db        "TYPE", 0
          dw        c_ver
          db        "VER", 0
          dw        c_verify
          db        "VERIFY", 0
          dw        c_vol
          db        "VOL", 0
          dw        0

dateseqs: dw        emdy, edmy, eymd

linbuf:   dw        0x0000              ; FALL INTO
buf:
